# 函数简介
#	-函数也是一个对象
#	-函数可以用来保存一些可执行的代码，并且可以在需要时，对这些语句进行多次的调用
#	-创建函数：
#		def 函数名([形参1,形参2,...]) :
#			代码块

# 在Python中，函数是一等对象
# 一等对象一般具有如下特点：
#	 -对象实在运行时创建
#	 -能赋值给变量或作为数据结构中的元素
#	 -能作为参数传递
#	 -能作为返回值返回
#
# 高阶函数：高阶函数至少要符合以下两个特点中的一个
#	 -接收一个或多个函数作为参数
#	 -将函数错位返回值返回


# 定义一个函数
def print_hello() :
	print('hello')
	print('这是一个函数！')

# print_hello是函数对象 print_hello()是调用函数
# <function print_hello at 0x0342A148>
# print(print_hello)
# <class 'function'>
# print(type(print_hello))

# 调用函数
# print_hello()


# 定义一个函数，含有形参
def get_num_sum(num1,num2) : 
	print('num1 + num2 =', num1 + num2)

# 调用函数 传递实参
# get_num_sum(10,20)


# 形参的设置
# 	-可以指定默认值，当没有传递参数时，默认值生效
def fn(a = 5, b = 10, c = 20) :
	print('a=', a)
	print('b=', b)
	print('c=', c)

# fn(1, 2, 3)
# fn(1, 2)
# fn()


# 实参的传递参数
#	-位置参数：就是对应位置的实参传递给对应位置的形参
#	-关键字参数：可以不按照形参定义的位置传递，可以根据参数名进行传递
#	-位置参数可以和关键字参数混合使用

# 位置参数
# fn(1, 2, 3)
# 关键字参数
# fn(b = 1, a = 2, c = 3)
# 混合使用
# fn(1, c = 30, b = 20)
# 混合使用时，位置参数放在前面
# fn(c = 30, b = 20, 1)	# 出错



def fn1(a) :
	print('a=', a)


# 函数在调用时，解析器不会检查实参的类型
# 实参可以传递任意类型的对象, 所以为了程序的严谨性，一般若需要会在函数体重检查参数的类型
# fn1('hello')
# fn1(123)
# fn1(True)
# fn1([1,2,3])
# fn1(fn)


def fn2(a) :
	# 在函数中对形参进行重新赋值，不会影响其他的变量
	# a = 20
	# a为列表，修改列表中的元素
	# 如果形参时一个对象，当通过形参去修改对象时，会影响到所有指向该对象的变量
	a[0] = 100
	print('a=', a, id(a))


b = 10
b = [1,2,3]

# fn2(b)
# 若不想修改对所有变量产生影响，可以使用copy浅复制或者切片
# fn2(b.copy())
# fn2(b[:])

# print('b=', b, id(b))




# 参数
# 不定长参数
# 在定义函数时，可以在形参前面加上*，这样这个形参将会获取所有实参
# 将所有的实参保存到一个元祖中， 也称为装包
# 不定长参数只能接受位置参数，不接受关键字参数
# a,b,*c = (1,2,3,4,5,6)
# 不定长参数只能有一个，可以和其他参数混合使用

# def fn3(a, b, *c) :
# 	print('a =', a)
# 	print('b =', b)
# 	print('c =', c)
# fn3(1,2,3,4,10,5)

# 不定长参数的后面的所有的参数传递都使用关键字参数传递
# def fn3(a, *b, c) :
# 	print('a =', a)
# 	print('b =', b)
# 	print('c =', c)
# fn3(1,2,3,4,5,c=5)

# def fn3(*a, b, c) :
# 	print('a =', a)
# 	print('b =', b)
# 	print('c =', c)
# fn3(1,2,3,4,b=10,c=5)

# 如果形参的开头直接是*，则要求后面的参数都要以关键字参数传递
# def fn3(*, a, b, c) :
# 	print('a =', a)
# 	print('b =', b)
# 	print('c =', c)

# fn3(a=4,b=10,c=5)



# **参数
# 接收所有的关键字参数，会将这些参数保存到一个字典中，参数名-key，参数值-value
# **参数只能有一个，只能写到所有参数的最后
# def fn4(**a) :
# 	print('a =', a, type(a))

def fn4(n1,n2,**a) :
	print('a =', a, type(a))
	print('n1 =', n1)
	print('n2 =', n2)

# a = {'b': 1, 'a': 3, 'c': 5} <class 'dict'>
# fn4(b=1,a=3,c=5,n1=10,n2=90)



# 参数的解包
def fn5(a,b,c) :
	print('a =', a)
	print('b =', b)
	print('c =', c)

# 传递参数时，可以在序列类型的参数前使用*
# 这样会自动将序列中的元素依次作为参数传递
# 要求序列中元素的个数和形参的个数一致
t = (10,20,30)
# fn5(*t)

# 使用**对字典进行解包
d = {'a':100,'b':200,'c':300}
# fn5(**d)




# 返回值：返回值也可以是任意对象
def my_sum(*nums) :
	result = 0
	for n in nums :
		result += n
	return result


result = my_sum(1,3,5,6,7)
# print(result)

# 如果没有return或者仅仅是一个return，则返回None
def fn6() :
	# a = 10
	return

r = fn6()
# None
# print(r)




# 文档字符串
# help()是Python中的内置函数，可以查询Python中的函数的用法
# 在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明
# 文档字符串尽量使用英文编写
# 文档字符串一般使用三个引号包含，也可以使用单引号或者双引号

# help(print)
# help(my_sum)

# :int 描述参数类型
# -> int 描述返回值
# c:str = 'hello' 用来表示默认值
# 这些描述只是描述，不影响其参数的实际类型，描述为int，我可以传str真阳
def my_fn(a:int, b:bool, c:str = 'hello') -> int :
	'''
	这是一个文档字符串的示例

	函数的作用：自定义函数

	函数的参数：
		a-参数1，作用，类型，默认值...
		b-参数2，作用，类型，默认值...
		c-参数3，作用，类型，默认值...
	'''

	return 10

# help(my_fn)




# 作用域（scope）：变量生效的区域
# 全局作用域
#	-全局作用域在程序执行时创建，在程序执行结束时销毁
#	-所有函数意外的区域都是全局作用域
#	-在全局作用域中定义的变量，都属于全局变量，可以在任意位置被访问
#
# 函数作用域
#	-在函数调用时创建，在调用结束时销毁
#	-函数每调用一次就会产生一个新的函数作用域
#	-函数作用域中的变量，都是局部变量，只能在函数内部被访问

# 变量的查找
#	-优先在当前作用域中寻找该变量，如果有则使用，如果没有则继续去上一级寻找
#	-若一直没有找到，则会报错


# 全局变量
a = 666

# 函数名称与其他函数名一样，则会覆盖该函数
def my_fn() :
	a = 20
	return a

# r = my_fn()
# print(r)

# 函数嵌套
def my_fn() :
	# 这里都是局部变量
	# a = 20

	# 若需要修改全局变量则需要使用globa关键字
	global a
	a = 999

	print('内部a=',a)

	# def my_fn1() :
	# 	a = 40
	# 	print('my_fn1中a=',a)

	# my_fn1()


# my_fn()
# print('外部a=',a)





# 命名空间（namespace）-变量存储的位置
# 每个作用域都会有一个对应的命名空间
# 全局命名空间，用来保存全局变量；函数命名空间用来保存函数中的变量
# 实际上是一个字典，是一个专门用来存储变量的字典

# locals()-获取当前作用域的命名空间
scope = locals()
# print(scope)
# print(a, scope['a'])
# 向字典中添加一项，等于创建了一个变量（一般不这么做）
# scope['abc'] = 1000
# print(abc)


def my_fn() :
	a = 101
	# 函数内部使用locals，则获取的是函数的命名空间
	scope = locals()
	print(scope)

	# 在任意位置获取全局命名空间
	global_scope = globals()
	print(global_scope)

# my_fn()






# 函数的递归

# 求任意数的的阶乘
#	1! = 1
#	2! = 1 * 2 = 2
#	3! = 1 * 2 * 3 = 6
#	......


def my_fn1(num) : 
	result = 1
	for i in range(1,num+1) :
		result *= i

	return result

# print(my_fn1(20))


# 无穷递归
# def my_fn() :
# 	my_fn()

# 递归的条件
#	1.基线条件-问题可以被分解为的最小问题，当满足基线条件时，递归就不再执行了
#	2.递归条件-将问题继续分解的条件

# 使用递归求阶乘
#	10! = 10 * 9!
#	9! = 9 * 8!
#	...
#	1! = 1
def my_fn1(num) :
	if num == 1 :
		return 1

	return num * my_fn1(num - 1)

# print(my_fn1(10))








